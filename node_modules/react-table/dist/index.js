'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = _interopDefault(require('react'));

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];

  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }

  return (hint === "string" ? String : Number)(input);
}

function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");

  return typeof key === "symbol" ? key : String(key);
}

var actions = {
  init: 'init'
};
var defaultColumn = {
  Cell: function Cell(_ref) {
    var _ref$cell$value = _ref.cell.value,
        value = _ref$cell$value === void 0 ? '' : _ref$cell$value;
    return String(value);
  },
  width: 150,
  minWidth: 0,
  maxWidth: Number.MAX_SAFE_INTEGER
};
function defaultOrderByFn(arr, funcs, dirs) {
  return _toConsumableArray(arr).sort(function (rowA, rowB) {
    for (var i = 0; i < funcs.length; i += 1) {
      var sortFn = funcs[i];
      var desc = dirs[i] === false || dirs[i] === 'desc';
      var sortInt = sortFn(rowA, rowB);

      if (sortInt !== 0) {
        return desc ? -sortInt : sortInt;
      }
    }

    return dirs[0] ? rowA.index - rowB.index : rowB.index - rowA.index;
  });
}
function defaultGroupByFn(rows, columnId) {
  return rows.reduce(function (prev, row, i) {
    // TODO: Might want to implement a key serializer here so
    // irregular column values can still be grouped if needed?
    var resKey = "".concat(row.values[columnId]);
    prev[resKey] = Array.isArray(prev[resKey]) ? prev[resKey] : [];
    prev[resKey].push(row);
    return prev;
  }, {});
}
var mergeProps = function mergeProps() {
  var props = {};

  for (var _len = arguments.length, groups = new Array(_len), _key = 0; _key < _len; _key++) {
    groups[_key] = arguments[_key];
  }

  groups.forEach(function () {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$style = _ref2.style,
        style = _ref2$style === void 0 ? {} : _ref2$style,
        className = _ref2.className,
        rest = _objectWithoutProperties(_ref2, ["style", "className"]);

    props = _objectSpread2({}, props, {}, rest, {
      style: _objectSpread2({}, props.style || {}, {}, style),
      className: [props.className, className].filter(Boolean).join(' ')
    });
  });

  if (props.className === '') {
    delete props.className;
  }

  return props;
};
var applyHooks = function applyHooks(hooks, initial) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
    args[_key2 - 2] = arguments[_key2];
  }

  return hooks.reduce(function (prev, next) {
    var nextValue = next.apply(void 0, [prev].concat(args));

    if (typeof nextValue === 'undefined') {
      throw new Error('React Table: A hook just returned undefined! This is not allowed.');
    }

    return nextValue;
  }, initial);
};
var applyPropHooks = function applyPropHooks(hooks) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }

  return hooks.reduce(function (prev, next) {
    return mergeProps(prev, next.apply(void 0, args));
  }, {});
};
function ensurePluginOrder(plugins, befores, pluginName, afters) {
  var pluginIndex = plugins.findIndex(function (plugin) {
    return plugin.pluginName === pluginName;
  });

  if (pluginIndex === -1) {
    throw new Error("The plugin ".concat(pluginName, " was not found in the plugin list!\nThis usually means you need to need to name your plugin hook by setting the 'pluginName' property of the hook function, eg:\n\n  ").concat(pluginName, ".pluginName = '").concat(pluginName, "'\n"));
  }

  befores.forEach(function (before) {
    var beforeIndex = plugins.findIndex(function (plugin) {
      return plugin.pluginName === before;
    });

    if (beforeIndex > -1 && beforeIndex > pluginIndex) {
      throw new Error("React Table: The ".concat(pluginName, " plugin hook must be placed after the ").concat(before, " plugin hook!"));
    }
  });
  afters.forEach(function (after) {
    var afterIndex = plugins.findIndex(function (plugin) {
      return plugin.pluginName === after;
    });

    if (afterIndex > -1 && afterIndex < pluginIndex) {
      throw new Error("React Table: The ".concat(pluginName, " plugin hook must be placed before the ").concat(after, " plugin hook!"));
    }
  });
}
function functionalUpdate(updater, old) {
  return typeof updater === 'function' ? updater(old) : updater;
}
function useGetLatest(obj) {
  var ref = React.useRef();
  ref.current = obj;
  return React.useCallback(function () {
    return ref.current;
  }, []);
} // SSR has issues with useLayoutEffect still, so use useEffect during SSR

var safeUseLayoutEffect = typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect;
function useMountedLayoutEffect(fn, deps) {
  var mountedRef = React.useRef(false);
  safeUseLayoutEffect(function () {
    if (mountedRef.current) {
      fn();
    }

    mountedRef.current = true; // eslint-disable-next-line
  }, deps);
}
function useAsyncDebounce(defaultFn) {
  var defaultWait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var debounceRef = React.useRef({});
  debounceRef.current.defaultFn = defaultFn;
  debounceRef.current.defaultWait = defaultWait;
  var debounce = React.useCallback(function _callee2() {
    var fn,
        wait,
        _args2 = arguments;
    return regeneratorRuntime.async(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            fn = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : debounceRef.current.defaultFn;
            wait = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : debounceRef.current.defaultWait;

            if (!debounceRef.current.promise) {
              debounceRef.current.promise = new Promise(function (resolve, reject) {
                debounceRef.current.resolve = resolve;
                debounceRef.current.reject = reject;
              });
            }

            if (debounceRef.current.timeout) {
              clearTimeout(debounceRef.current.timeout);
            }

            debounceRef.current.timeout = setTimeout(function _callee() {
              return regeneratorRuntime.async(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      delete debounceRef.current.timeout;
                      _context.prev = 1;
                      _context.t0 = debounceRef.current;
                      _context.next = 5;
                      return regeneratorRuntime.awrap(fn());

                    case 5:
                      _context.t1 = _context.sent;

                      _context.t0.resolve.call(_context.t0, _context.t1);

                      _context.next = 12;
                      break;

                    case 9:
                      _context.prev = 9;
                      _context.t2 = _context["catch"](1);
                      debounceRef.current.reject(_context.t2);

                    case 12:
                      _context.prev = 12;
                      delete debounceRef.current.promise;
                      return _context.finish(12);

                    case 15:
                    case "end":
                      return _context.stop();
                  }
                }
              }, null, null, [[1, 9, 12, 15]]);
            }, wait);
            return _context2.abrupt("return", debounceRef.current.promise);

          case 6:
          case "end":
            return _context2.stop();
        }
      }
    });
  }, []);
  return debounce;
}
function useConsumeHookGetter(hooks, hookName) {
  var getter = useGetLatest(hooks[hookName]);
  hooks[hookName] = undefined;
  return getter;
}

function decorateColumn(column, userDefaultColumn, parent, depth, index) {
  // Apply the userDefaultColumn
  column = _objectSpread2({}, defaultColumn, {}, userDefaultColumn, {}, column); // First check for string accessor

  var _column = column,
      id = _column.id,
      accessor = _column.accessor,
      Header = _column.Header;

  if (typeof accessor === 'string') {
    id = id || accessor;
    var accessorPath = accessor.split('.');

    accessor = function accessor(row) {
      return getBy(row, accessorPath);
    };
  }

  if (!id && typeof Header === 'string' && Header) {
    id = Header;
  }

  if (!id && column.columns) {
    console.error(column);
    throw new Error('A column ID (or unique "Header" value) is required!');
  }

  if (!id) {
    console.error(column);
    throw new Error('A column ID (or string accessor) is required!');
  }

  column = _objectSpread2({
    // Make sure there is a fallback header, just in case
    Header: function Header() {
      return React.createElement(React.Fragment, null, "\xA0");
    },
    Footer: function Footer() {
      return React.createElement(React.Fragment, null, "\xA0");
    }
  }, column, {
    // Materialize and override this stuff
    id: id,
    accessor: accessor,
    parent: parent,
    depth: depth,
    index: index
  });
  return column;
} // Build the visible columns, headers and flat column list


function decorateColumnTree(columns, defaultColumn, parent) {
  var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  return columns.map(function (column, columnIndex) {
    column = decorateColumn(column, defaultColumn, parent, depth, columnIndex);

    if (column.columns) {
      column.columns = decorateColumnTree(column.columns, defaultColumn, column, depth + 1);
    }

    return column;
  });
} // Build the header groups from the bottom up

function makeHeaderGroups(flatColumns, defaultColumn) {
  var headerGroups = []; // Build each header group from the bottom up

  var buildGroup = function buildGroup(columns, depth) {
    var headerGroup = {
      headers: []
    };
    var parentColumns = []; // Do any of these columns have parents?

    var hasParents = columns.some(function (col) {
      return col.parent;
    });
    columns.forEach(function (column) {
      // Are we the first column in this group?
      var isFirst = !parentColumns.length; // What is the latest (last) parent column?

      var latestParentColumn = [].concat(parentColumns).reverse()[0]; // If the column has a parent, add it if necessary

      if (column.parent) {
        var similarParentColumns = parentColumns.filter(function (d) {
          return d.originalId === column.parent.id;
        });

        if (isFirst || latestParentColumn.originalId !== column.parent.id) {
          parentColumns.push(_objectSpread2({}, column.parent, {
            originalId: column.parent.id,
            id: [column.parent.id, similarParentColumns.length].join('_')
          }));
        }
      } else if (hasParents) {
        // If other columns have parents, we'll need to add a place holder if necessary
        var originalId = [column.id, 'placeholder'].join('_');

        var _similarParentColumns = parentColumns.filter(function (d) {
          return d.originalId === originalId;
        });

        var placeholderColumn = decorateColumn({
          originalId: originalId,
          id: [column.id, 'placeholder', _similarParentColumns.length].join('_'),
          placeholderOf: column
        }, defaultColumn);

        if (isFirst || latestParentColumn.originalId !== placeholderColumn.originalId) {
          parentColumns.push(placeholderColumn);
        }
      } // Establish the new headers[] relationship on the parent


      if (column.parent || hasParents) {
        latestParentColumn = [].concat(parentColumns).reverse()[0];
        latestParentColumn.headers = latestParentColumn.headers || [];

        if (!latestParentColumn.headers.includes(column)) {
          latestParentColumn.headers.push(column);
        }
      }

      column.totalHeaderCount = column.headers ? column.headers.reduce(function (sum, header) {
        return sum + header.totalHeaderCount;
      }, 0) : 1; // Leaf node columns take up at least one count

      headerGroup.headers.push(column);
    });
    headerGroups.push(headerGroup);

    if (parentColumns.length) {
      buildGroup(parentColumns);
    }
  };

  buildGroup(flatColumns);
  return headerGroups.reverse();
}
var pathObjCache = new Map();
function getBy(obj, path, def) {
  if (!path) {
    return obj;
  }

  var cacheKey = typeof path === 'function' ? path : JSON.stringify(path);

  var pathObj = pathObjCache.get(cacheKey) || function () {
    var pathObj = makePathArray(path);
    pathObjCache.set(cacheKey, pathObj);
    return pathObj;
  }();

  var val;

  try {
    val = pathObj.reduce(function (cursor, pathPart) {
      return cursor[pathPart];
    }, obj);
  } catch (e) {// continue regardless of error
  }

  return typeof val !== 'undefined' ? val : def;
}
function getFirstDefined() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  for (var i = 0; i < args.length; i += 1) {
    if (typeof args[i] !== 'undefined') {
      return args[i];
    }
  }
}
function flexRender(Comp, props) {
  return isReactComponent(Comp) ? React.createElement(Comp, props) : Comp;
}

function isClassComponent(component) {
  return typeof component === 'function' && !!function () {
    var proto = Object.getPrototypeOf(component);
    return proto.prototype && proto.prototype.isReactComponent;
  }();
}

function isFunctionComponent(component) {
  return typeof component === 'function';
}

function isReactComponent(component) {
  return isClassComponent(component) || isFunctionComponent(component);
}

function isFunction(a) {
  if (typeof a === 'function') {
    return a;
  }
}
function flattenBy(columns, childKey) {
  var flatColumns = [];

  var recurse = function recurse(columns) {
    columns.forEach(function (d) {
      if (!d[childKey]) {
        flatColumns.push(d);
      } else {
        recurse(d[childKey]);
      }
    });
  };

  recurse(columns);
  return flatColumns;
}
function expandRows(rows, _ref) {
  var manualExpandedKey = _ref.manualExpandedKey,
      expanded = _ref.expanded,
      _ref$expandSubRows = _ref.expandSubRows,
      expandSubRows = _ref$expandSubRows === void 0 ? true : _ref$expandSubRows;
  var expandedRows = [];

  var handleRow = function handleRow(row) {
    var key = row.path.join('.');
    row.isExpanded = row.original && row.original[manualExpandedKey] || expanded.includes(key);
    row.canExpand = row.subRows && !!row.subRows.length;
    expandedRows.push(row);

    if (expandSubRows && row.subRows && row.subRows.length && row.isExpanded) {
      row.subRows.forEach(handleRow);
    }
  };

  rows.forEach(handleRow);
  return expandedRows;
} //

var reOpenBracket = /\[/g;
var reCloseBracket = /\]/g;

function makePathArray(obj) {
  return flattenDeep(obj) // remove all periods in parts
  .map(function (d) {
    return String(d).replace('.', '_');
  }) // join parts using period
  .join('.') // replace brackets with periods
  .replace(reOpenBracket, '.').replace(reCloseBracket, '') // split it back out on periods
  .split('.');
}

function flattenDeep(arr) {
  var newArr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if (!Array.isArray(arr)) {
    newArr.push(arr);
  } else {
    for (var i = 0; i < arr.length; i += 1) {
      flattenDeep(arr[i], newArr);
    }
  }

  return newArr;
}

actions.resetHiddenColumns = 'resetHiddenColumns';
actions.toggleHideColumn = 'toggleHideColumn';
actions.setHiddenColumns = 'setHiddenColumns';
actions.toggleHideAllColumns = 'toggleHideAllColumns';
var useColumnVisibility = function useColumnVisibility(hooks) {
  hooks.getToggleHiddenProps = [];
  hooks.getToggleHideAllColumnsProps = [];
  hooks.stateReducers.push(reducer);
  hooks.useInstanceBeforeDimensions.push(useInstanceBeforeDimensions);
  hooks.headerGroupsDeps.push(function (deps, instance) {
    return [].concat(_toConsumableArray(deps), [instance.state.hiddenColumns]);
  });
  hooks.useInstance.push(useInstance);
};
useColumnVisibility.pluginName = 'useColumnVisibility';

function reducer(state, action, previousState, instanceRef) {
  if (action.type === actions.init) {
    return _objectSpread2({
      hiddenColumns: []
    }, state);
  }

  if (action.type === actions.resetHiddenColumns) {
    return _objectSpread2({}, state, {
      hiddenColumns: []
    });
  }

  if (action.type === actions.toggleHideColumn) {
    var should = typeof action.value !== 'undefined' ? action.value : !state.hiddenColumns.includes(action.columnId);
    var hiddenColumns = should ? [].concat(_toConsumableArray(state.hiddenColumns), [action.columnId]) : state.hiddenColumns.filter(function (d) {
      return d !== action.columnId;
    });
    return _objectSpread2({}, state, {
      hiddenColumns: hiddenColumns
    });
  }

  if (action.type === actions.setHiddenColumns) {
    return _objectSpread2({}, state, {
      hiddenColumns: functionalUpdate(action.value, state.hiddenColumns)
    });
  }

  if (action.type === actions.toggleHideAllColumns) {
    var shouldAll = typeof action.value !== 'undefined' ? action.value : !state.hiddenColumns.length;
    return _objectSpread2({}, state, {
      hiddenColumns: shouldAll ? instanceRef.current.flatColumns.map(function (d) {
        return d.id;
      }) : []
    });
  }
}

function useInstanceBeforeDimensions(instance) {
  var headers = instance.headers,
      hiddenColumns = instance.state.hiddenColumns;

  var handleColumn = function handleColumn(column, parentVisible) {
    column.isVisible = parentVisible && !hiddenColumns.includes(column.id);
    var totalVisibleHeaderCount = 0;

    if (column.headers && column.headers.length) {
      column.headers.forEach(function (subColumn) {
        return totalVisibleHeaderCount += handleColumn(subColumn, column.isVisible);
      });
    } else {
      totalVisibleHeaderCount = column.isVisible ? 1 : 0;
    }

    column.totalVisibleHeaderCount = totalVisibleHeaderCount;
    return totalVisibleHeaderCount;
  };

  var totalVisibleHeaderCount = 0;
  headers.forEach(function (subHeader) {
    return totalVisibleHeaderCount += handleColumn(subHeader, true);
  });
  return instance;
}

function useInstance(instance) {
  var flatHeaders = instance.flatHeaders,
      dispatch = instance.dispatch,
      flatColumns = instance.flatColumns,
      hiddenColumns = instance.state.hiddenColumns;
  var getInstance = useGetLatest(instance);
  var allColumnsHidden = flatColumns.length === hiddenColumns.length;
  flatHeaders.forEach(function (column) {
    column.toggleHidden = function (value) {
      dispatch({
        type: actions.toggleHideColumn,
        columnId: column.id,
        value: value
      });
    };

    column.getToggleHiddenProps = function (props) {
      return mergeProps({
        onChange: function onChange(e) {
          column.toggleHidden(!e.target.checked);
        },
        style: {
          cursor: 'pointer'
        },
        checked: column.isVisible,
        title: 'Toggle Column Visible'
      }, applyPropHooks(getInstance().hooks.getToggleHiddenProps, getInstance()), props);
    };
  });
  var toggleHideColumn = React.useCallback(function (columnId, value) {
    return dispatch({
      type: actions.toggleHideColumn,
      columnId: columnId,
      value: value
    });
  }, [dispatch]);
  var setHiddenColumns = React.useCallback(function (value) {
    return dispatch({
      type: actions.setHiddenColumns,
      value: value
    });
  }, [dispatch]);
  var toggleHideAllColumns = React.useCallback(function (value) {
    return dispatch({
      type: actions.toggleHideAllColumns,
      value: value
    });
  }, [dispatch]);

  var getToggleHideAllColumnsProps = function getToggleHideAllColumnsProps(props) {
    return mergeProps({
      onChange: function onChange(e) {
        toggleHideAllColumns(!e.target.checked);
      },
      style: {
        cursor: 'pointer'
      },
      checked: !allColumnsHidden && !hiddenColumns.length,
      title: 'Toggle All Columns Hidden',
      indeterminate: !allColumnsHidden && hiddenColumns.length
    }, applyPropHooks(getInstance().hooks.getToggleHideAllColumnsProps, getInstance()), props);
  };

  return _objectSpread2({}, instance, {
    toggleHideColumn: toggleHideColumn,
    setHiddenColumns: setHiddenColumns,
    toggleHideAllColumns: toggleHideAllColumns,
    getToggleHideAllColumnsProps: getToggleHideAllColumnsProps
  });
}

var renderErr = 'Renderer Error';
var defaultInitialState = {};
var defaultColumnInstance = {};

var defaultReducer = function defaultReducer(state, action, prevState) {
  return state;
};

var defaultGetSubRows = function defaultGetSubRows(row, index) {
  return row.subRows || [];
};

var defaultGetRowId = function defaultGetRowId(row, index) {
  return index;
};

var defaultUseControlledState = function defaultUseControlledState(d) {
  return d;
};

var useTable = function useTable(props) {
  for (var _len = arguments.length, plugins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    plugins[_key - 1] = arguments[_key];
  }

  // Destructure props
  var data = props.data,
      userColumns = props.columns,
      _props$initialState = props.initialState,
      initialState = _props$initialState === void 0 ? defaultInitialState : _props$initialState,
      _props$defaultColumn = props.defaultColumn,
      defaultColumn = _props$defaultColumn === void 0 ? defaultColumnInstance : _props$defaultColumn,
      _props$getSubRows = props.getSubRows,
      getSubRows = _props$getSubRows === void 0 ? defaultGetSubRows : _props$getSubRows,
      _props$getRowId = props.getRowId,
      getRowId = _props$getRowId === void 0 ? defaultGetRowId : _props$getRowId,
      _props$stateReducer = props.stateReducer,
      userStateReducer = _props$stateReducer === void 0 ? defaultReducer : _props$stateReducer,
      _props$useControlledS = props.useControlledState,
      useControlledState = _props$useControlledS === void 0 ? defaultUseControlledState : _props$useControlledS;
  plugins = [useColumnVisibility].concat(_toConsumableArray(plugins)); // The table instance

  var instanceRef = React.useRef({});
  Object.assign(instanceRef.current, _objectSpread2({}, props, {
    plugins: plugins,
    data: data,
    hooks: {
      stateReducers: [],
      columns: [],
      columnsDeps: [],
      flatColumns: [],
      flatColumnsDeps: [],
      headerGroups: [],
      headerGroupsDeps: [],
      useInstanceBeforeDimensions: [],
      useInstance: [],
      useRows: [],
      prepareRow: [],
      getTableProps: [],
      getTableBodyProps: [],
      getRowProps: [],
      getHeaderGroupProps: [],
      getFooterGroupProps: [],
      getHeaderProps: [],
      getFooterProps: [],
      getCellProps: []
    }
  })); // Allow plugins to register hooks as early as possible

  plugins.filter(Boolean).forEach(function (plugin) {
    plugin(instanceRef.current.hooks);
  }); // Snapshot hook and disallow more from being added

  var getStateReducers = useConsumeHookGetter(instanceRef.current.hooks, 'stateReducers'); // Setup user reducer ref

  var getUserStateReducer = useGetLatest(userStateReducer); // Build the reducer

  var reducer = React.useCallback(function (state, action) {
    // Detect invalid actions
    if (!action.type) {
      console.info({
        action: action
      });
      throw new Error('Unknown Action 👆');
    } // Reduce the state from all plugin reducers


    return [].concat(_toConsumableArray(getStateReducers()), _toConsumableArray(Array.isArray(getUserStateReducer()) ? getUserStateReducer() : [getUserStateReducer()])).reduce(function (s, handler) {
      return handler(s, action, state, instanceRef) || s;
    }, state);
  }, [getStateReducers, getUserStateReducer]); // Start the reducer

  var _React$useReducer = React.useReducer(reducer, undefined, function () {
    return reducer(initialState, {
      type: actions.init
    });
  }),
      _React$useReducer2 = _slicedToArray(_React$useReducer, 2),
      reducerState = _React$useReducer2[0],
      dispatch = _React$useReducer2[1]; // Allow the user to control the final state with hooks


  var state = useControlledState(reducerState);
  Object.assign(instanceRef.current, {
    state: state,
    // The state dispatcher
    dispatch: dispatch // The resolved table state

  }); // Snapshot hook and disallow more from being added

  var getColumns = useConsumeHookGetter(instanceRef.current.hooks, 'columns'); // Snapshot hook and disallow more from being added

  var getColumnsDeps = useConsumeHookGetter(instanceRef.current.hooks, 'columnsDeps'); // Decorate All the columns

  var columns = React.useMemo(function () {
    return applyHooks(getColumns(), decorateColumnTree(userColumns, defaultColumn), instanceRef.current);
  }, [defaultColumn, getColumns, userColumns].concat(_toConsumableArray(getColumnsDeps(instanceRef.current))));
  instanceRef.current.columns = columns; // Snapshot hook and disallow more from being added

  var getFlatColumns = useConsumeHookGetter(instanceRef.current.hooks, 'flatColumns'); // Snapshot hook and disallow more from being added

  var getFlatColumnsDeps = useConsumeHookGetter(instanceRef.current.hooks, 'flatColumnsDeps'); // Get the flat list of all columns and allow hooks to decorate
  // those columns (and trigger this memoization via deps)

  var flatColumns = React.useMemo(function () {
    return applyHooks(getFlatColumns(), flattenBy(columns, 'columns'), instanceRef.current);
  }, [columns, getFlatColumns].concat(_toConsumableArray(getFlatColumnsDeps(instanceRef.current))));
  instanceRef.current.flatColumns = flatColumns; // Snapshot hook and disallow more from being added

  var getHeaderGroups = useConsumeHookGetter(instanceRef.current.hooks, 'headerGroups'); // Snapshot hook and disallow more from being added

  var getHeaderGroupsDeps = useConsumeHookGetter(instanceRef.current.hooks, 'headerGroupsDeps'); // Make the headerGroups

  var headerGroups = React.useMemo(function () {
    return applyHooks(getHeaderGroups(), makeHeaderGroups(flatColumns, defaultColumn), instanceRef.current);
  }, [defaultColumn, flatColumns, getHeaderGroups].concat(_toConsumableArray(getHeaderGroupsDeps())));
  instanceRef.current.headerGroups = headerGroups;
  var headers = React.useMemo(function () {
    return headerGroups.length ? headerGroups[0].headers : [];
  }, [headerGroups]);
  instanceRef.current.headers = headers; // Access the row model

  var _React$useMemo = React.useMemo(function () {
    var flatRows = []; // Access the row's data

    var accessRow = function accessRow(originalRow, i) {
      var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var parentPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      // Keep the original reference around
      var original = originalRow;
      var rowId = getRowId(originalRow, i); // Make the new path for the row

      var path = [].concat(_toConsumableArray(parentPath), [rowId]);
      var row = {
        original: original,
        index: i,
        path: path,
        // used to create a key for each row even if not nested
        depth: depth,
        cells: [{}] // This is a dummy cell

      };
      flatRows.push(row); // Process any subRows

      var subRows = getSubRows(originalRow, i);

      if (subRows) {
        row.subRows = subRows.map(function (d, i) {
          return accessRow(d, i, depth + 1, path);
        });
      } // Override common array functions (and the dummy cell's getCellProps function)
      // to show an error if it is accessed without calling prepareRow


      var unpreparedAccessWarning = function unpreparedAccessWarning() {
        throw new Error('React-Table: You have not called prepareRow(row) one or more rows you are attempting to render.');
      };

      row.cells.map = unpreparedAccessWarning;
      row.cells.filter = unpreparedAccessWarning;
      row.cells.forEach = unpreparedAccessWarning;
      row.cells[0].getCellProps = unpreparedAccessWarning; // Create the cells and values

      row.values = {};
      flatColumns.forEach(function (column) {
        row.values[column.id] = column.accessor ? column.accessor(originalRow, i, {
          subRows: subRows,
          depth: depth,
          data: data
        }) : undefined;
      });
      return row;
    }; // Use the resolved data


    var accessedData = data.map(function (d, i) {
      return accessRow(d, i);
    });
    return [accessedData, flatRows];
  }, [data, getRowId, getSubRows, flatColumns]),
      _React$useMemo2 = _slicedToArray(_React$useMemo, 2),
      rows = _React$useMemo2[0],
      flatRows = _React$useMemo2[1];

  instanceRef.current.rows = rows;
  instanceRef.current.flatRows = flatRows; // Provide a flat header list for utilities

  instanceRef.current.flatHeaders = headerGroups.reduce(function (all, headerGroup) {
    return [].concat(_toConsumableArray(all), _toConsumableArray(headerGroup.headers));
  }, []); // Snapshot hook and disallow more from being added

  var getUseInstanceBeforeDimensions = useConsumeHookGetter(instanceRef.current.hooks, 'useInstanceBeforeDimensions');
  instanceRef.current = applyHooks(getUseInstanceBeforeDimensions(), instanceRef.current); // Header Visibility is needed by this point

  calculateDimensions(instanceRef.current); // Snapshot hook and disallow more from being added

  var getUseInstance = useConsumeHookGetter(instanceRef.current.hooks, 'useInstance');
  instanceRef.current = applyHooks(getUseInstance(), instanceRef.current); // Snapshot hook and disallow more from being added

  var getHeaderPropsHooks = useConsumeHookGetter(instanceRef.current.hooks, 'getHeaderProps'); // Snapshot hook and disallow more from being added

  var getFooterPropsHooks = useConsumeHookGetter(instanceRef.current.hooks, 'getFooterProps'); // Each materialized header needs to be assigned a render function and other
  // prop getter properties here.

  instanceRef.current.flatHeaders.forEach(function (column) {
    // Give columns/headers rendering power
    column.render = function (type) {
      var userProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var Comp = typeof type === 'string' ? column[type] : type;

      if (typeof Comp === 'undefined') {
        throw new Error(renderErr);
      }

      return flexRender(Comp, _objectSpread2({}, instanceRef.current, {
        column: column
      }, userProps));
    }; // Give columns/headers a default getHeaderProps


    column.getHeaderProps = function (props) {
      return mergeProps({
        key: ['header', column.id].join('_'),
        colSpan: column.totalVisibleHeaderCount
      }, applyPropHooks(getHeaderPropsHooks(), column, instanceRef.current), props);
    }; // Give columns/headers a default getFooterProps


    column.getFooterProps = function (props) {
      return mergeProps({
        key: ['footer', column.id].join('_'),
        colSpan: column.totalVisibleHeaderCount
      }, applyPropHooks(getFooterPropsHooks(), column, instanceRef.current), props);
    };
  }); // Snapshot hook and disallow more from being added

  var getHeaderGroupPropsHooks = useConsumeHookGetter(instanceRef.current.hooks, 'getHeaderGroupProps'); // Snapshot hook and disallow more from being added

  var getFooterGroupsPropsHooks = useConsumeHookGetter(instanceRef.current.hooks, 'getFooterGroupProps');
  instanceRef.current.headerGroups = instanceRef.current.headerGroups.filter(function (headerGroup, i) {
    // Filter out any headers and headerGroups that don't have visible columns
    headerGroup.headers = headerGroup.headers.filter(function (column) {
      var recurse = function recurse(headers) {
        return headers.filter(function (column) {
          if (column.headers) {
            return recurse(column.headers);
          }

          return column.isVisible;
        }).length;
      };

      if (column.headers) {
        return recurse(column.headers);
      }

      return column.isVisible;
    }); // Give headerGroups getRowProps

    if (headerGroup.headers.length) {
      headerGroup.getHeaderGroupProps = function () {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return mergeProps({
          key: ["header".concat(i)].join('_')
        }, applyPropHooks(getHeaderGroupPropsHooks(), headerGroup, instanceRef.current), props);
      };

      headerGroup.getFooterGroupProps = function () {
        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return mergeProps({
          key: ["footer".concat(i)].join('_')
        }, applyPropHooks(getFooterGroupsPropsHooks(), headerGroup, instanceRef.current), props);
      };

      return true;
    }

    return false;
  });
  instanceRef.current.footerGroups = _toConsumableArray(instanceRef.current.headerGroups).reverse(); // Run the rows (this could be a dangerous hook with a ton of data)
  // Snapshot hook and disallow more from being added

  var getUseRowsHooks = useConsumeHookGetter(instanceRef.current.hooks, 'useRows');
  instanceRef.current.rows = applyHooks(getUseRowsHooks(), instanceRef.current.rows, instanceRef.current); // The prepareRow function is absolutely necessary and MUST be called on
  // any rows the user wishes to be displayed.
  // Snapshot hook and disallow more from being added

  var getPrepareRowHooks = useConsumeHookGetter(instanceRef.current.hooks, 'prepareRow'); // Snapshot hook and disallow more from being added

  var getRowPropsHooks = useConsumeHookGetter(instanceRef.current.hooks, 'getRowProps'); // Snapshot hook and disallow more from being added

  var getCellPropsHooks = useConsumeHookGetter(instanceRef.current.hooks, 'getCellProps');
  instanceRef.current.prepareRow = React.useCallback(function (row) {
    row.getRowProps = function (props) {
      return mergeProps({
        key: ['row'].concat(_toConsumableArray(row.path)).join('_')
      }, applyPropHooks(getRowPropsHooks(), row, instanceRef.current), props);
    }; // Build the visible cells for each row


    row.cells = instanceRef.current.flatColumns.filter(function (d) {
      return d.isVisible;
    }).map(function (column) {
      var cell = {
        column: column,
        row: row,
        value: row.values[column.id]
      }; // Give each cell a getCellProps base

      cell.getCellProps = function (props) {
        var columnPathStr = [].concat(_toConsumableArray(row.path), [column.id]).join('_');
        return mergeProps({
          key: ['cell', columnPathStr].join('_')
        }, applyPropHooks(getCellPropsHooks(), cell, instanceRef.current), props);
      }; // Give each cell a renderer function (supports multiple renderers)


      cell.render = function (type) {
        var userProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var Comp = typeof type === 'string' ? column[type] : type;

        if (typeof Comp === 'undefined') {
          throw new Error(renderErr);
        }

        return flexRender(Comp, _objectSpread2({}, instanceRef.current, {
          column: column,
          row: row,
          cell: cell
        }, userProps));
      };

      return cell;
    }); // need to apply any row specific hooks (useExpanded requires this)

    applyHooks(getPrepareRowHooks(), row, instanceRef.current);
  }, [getCellPropsHooks, getPrepareRowHooks, getRowPropsHooks]); // Snapshot hook and disallow more from being added

  var getTablePropsHooks = useConsumeHookGetter(instanceRef.current.hooks, 'getTableProps');

  instanceRef.current.getTableProps = function (userProps) {
    return mergeProps(applyPropHooks(getTablePropsHooks(), instanceRef.current), userProps);
  }; // Snapshot hook and disallow more from being added


  var getTableBodyPropsHooks = useConsumeHookGetter(instanceRef.current.hooks, 'getTableBodyProps');

  instanceRef.current.getTableBodyProps = function (userProps) {
    return mergeProps(applyPropHooks(getTableBodyPropsHooks(), instanceRef.current), userProps);
  };

  return instanceRef.current;
};

function calculateDimensions(instance) {
  var headers = instance.headers;
  instance.totalColumnsWidth = calculateHeaderWidths(headers);
}

function calculateHeaderWidths(headers) {
  var left = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var sumTotalWidth = 0;
  headers.forEach(function (header) {
    var subHeaders = header.headers;
    header.totalLeft = left;

    if (subHeaders && subHeaders.length) {
      header.totalWidth = calculateHeaderWidths(subHeaders, left);
    } else {
      header.totalWidth = Math.min(Math.max(header.minWidth, header.width), header.maxWidth);
    }

    if (header.isVisible) {
      left += header.totalWidth;
      sumTotalWidth += header.totalWidth;
    }
  });
  return sumTotalWidth;
}

actions.toggleExpandedByPath = 'toggleExpandedByPath';
actions.resetExpanded = 'resetExpanded';
var useExpanded = function useExpanded(hooks) {
  hooks.getExpandedToggleProps = [];
  hooks.stateReducers.push(reducer$1);
  hooks.useInstance.push(useInstance$1);
};
useExpanded.pluginName = 'useExpanded'; // Reducer

function reducer$1(state, action) {
  if (action.type === actions.init) {
    return _objectSpread2({
      expanded: []
    }, state);
  }

  if (action.type === actions.resetExpanded) {
    return _objectSpread2({}, state, {
      expanded: []
    });
  }

  if (action.type === actions.toggleExpandedByPath) {
    var path = action.path,
        expanded = action.expanded;
    var key = path.join('.');
    var exists = state.expanded.includes(key);
    var shouldExist = typeof expanded !== 'undefined' ? expanded : !exists;
    var newExpanded = new Set(state.expanded);

    if (!exists && shouldExist) {
      newExpanded.add(key);
    } else if (exists && !shouldExist) {
      newExpanded.delete(key);
    } else {
      return state;
    }

    return _objectSpread2({}, state, {
      expanded: _toConsumableArray(newExpanded.values())
    });
  }
}

function useInstance$1(instance) {
  var data = instance.data,
      rows = instance.rows,
      _instance$manualExpan = instance.manualExpandedKey,
      manualExpandedKey = _instance$manualExpan === void 0 ? 'expanded' : _instance$manualExpan,
      _instance$paginateExp = instance.paginateExpandedRows,
      paginateExpandedRows = _instance$paginateExp === void 0 ? true : _instance$paginateExp,
      _instance$expandSubRo = instance.expandSubRows,
      expandSubRows = _instance$expandSubRo === void 0 ? true : _instance$expandSubRo,
      hooks = instance.hooks,
      _instance$autoResetEx = instance.autoResetExpanded,
      autoResetExpanded = _instance$autoResetEx === void 0 ? true : _instance$autoResetEx,
      expanded = instance.state.expanded,
      dispatch = instance.dispatch;
  var getAutoResetExpanded = useGetLatest(autoResetExpanded); // Bypass any effects from firing when this changes

  useMountedLayoutEffect(function () {
    if (getAutoResetExpanded()) {
      dispatch({
        type: actions.resetExpanded
      });
    }
  }, [dispatch, data]);

  var toggleExpandedByPath = function toggleExpandedByPath(path, expanded) {
    dispatch({
      type: actions.toggleExpandedByPath,
      path: path,
      expanded: expanded
    });
  }; // use reference to avoid memory leak in #1608


  var instanceRef = React.useRef();
  instanceRef.current = instance;
  hooks.prepareRow.push(function (row) {
    row.toggleExpanded = function (set) {
      return toggleExpandedByPath(row.path, set);
    };

    row.getExpandedToggleProps = function (props) {
      return mergeProps({
        onClick: function onClick(e) {
          e.persist();
          row.toggleExpanded();
        },
        style: {
          cursor: 'pointer'
        },
        title: 'Toggle Expanded'
      }, applyPropHooks(instanceRef.current.hooks.getExpandedToggleProps, row, instanceRef.current), props);
    };

    return row;
  });
  var expandedRows = React.useMemo(function () {
    if (paginateExpandedRows) {
      return expandRows(rows, {
        manualExpandedKey: manualExpandedKey,
        expanded: expanded,
        expandSubRows: expandSubRows
      });
    }

    return rows;
  }, [paginateExpandedRows, rows, manualExpandedKey, expanded, expandSubRows]);
  var expandedDepth = findExpandedDepth(expanded);
  return _objectSpread2({}, instance, {
    toggleExpandedByPath: toggleExpandedByPath,
    expandedDepth: expandedDepth,
    rows: expandedRows
  });
}

function findExpandedDepth(expanded) {
  var maxDepth = 0;
  expanded.forEach(function (key) {
    var path = key.split('.');
    maxDepth = Math.max(maxDepth, path.length);
  });
  return maxDepth;
}

var text = function text(rows, id, filterValue) {
  rows = rows.filter(function (row) {
    var rowValue = row.values[id];
    return String(rowValue).toLowerCase().includes(String(filterValue).toLowerCase());
  });
  return rows;
};

text.autoRemove = function (val) {
  return !val;
};

var exactText = function exactText(rows, id, filterValue) {
  return rows.filter(function (row) {
    var rowValue = row.values[id];
    return rowValue !== undefined ? String(rowValue).toLowerCase() === String(filterValue).toLowerCase() : true;
  });
};

exactText.autoRemove = function (val) {
  return !val;
};

var exactTextCase = function exactTextCase(rows, id, filterValue) {
  return rows.filter(function (row) {
    var rowValue = row.values[id];
    return rowValue !== undefined ? String(rowValue) === String(filterValue) : true;
  });
};

exactTextCase.autoRemove = function (val) {
  return !val;
};

var includes = function includes(rows, id, filterValue) {
  return rows.filter(function (row) {
    var rowValue = row.values[id];
    return filterValue.includes(rowValue);
  });
};

includes.autoRemove = function (val) {
  return !val || !val.length;
};

var includesAll = function includesAll(rows, id, filterValue) {
  return rows.filter(function (row) {
    var rowValue = row.values[id];
    return rowValue && rowValue.length && filterValue.every(function (val) {
      return rowValue.includes(val);
    });
  });
};

includesAll.autoRemove = function (val) {
  return !val || !val.length;
};

var exact = function exact(rows, id, filterValue) {
  return rows.filter(function (row) {
    var rowValue = row.values[id];
    return rowValue === filterValue;
  });
};

exact.autoRemove = function (val) {
  return typeof val === 'undefined';
};

var equals = function equals(rows, id, filterValue) {
  return rows.filter(function (row) {
    var rowValue = row.values[id]; // eslint-disable-next-line eqeqeq

    return rowValue == filterValue;
  });
};

equals.autoRemove = function (val) {
  return val == null;
};

var between = function between(rows, id, filterValue) {
  var _ref = filterValue || [],
      _ref2 = _slicedToArray(_ref, 2),
      min = _ref2[0],
      max = _ref2[1];

  min = typeof min === 'number' ? min : -Infinity;
  max = typeof max === 'number' ? max : Infinity;

  if (min > max) {
    var temp = min;
    min = max;
    max = temp;
  }

  return rows.filter(function (row) {
    var rowValue = row.values[id];
    return rowValue >= min && rowValue <= max;
  });
};

between.autoRemove = function (val) {
  return !val || typeof val[0] !== 'number' && typeof val[1] !== 'number';
};

var filterTypes = /*#__PURE__*/Object.freeze({
  __proto__: null,
  text: text,
  exactText: exactText,
  exactTextCase: exactTextCase,
  includes: includes,
  includesAll: includesAll,
  exact: exact,
  equals: equals,
  between: between
});

actions.resetFilters = 'resetFilters';
actions.setFilter = 'setFilter';
actions.setAllFilters = 'setAllFilters';
var useFilters = function useFilters(hooks) {
  hooks.stateReducers.push(reducer$2);
  hooks.useInstance.push(useInstance$2);
};
useFilters.pluginName = 'useFilters';

function reducer$2(state, action, previousState, instanceRef) {
  if (action.type === actions.init) {
    return _objectSpread2({
      filters: {}
    }, state);
  }

  if (action.type === actions.resetFilters) {
    return _objectSpread2({}, state, {
      filters: {}
    });
  }

  if (action.type === actions.setFilter) {
    var columnId = action.columnId,
        filterValue = action.filterValue;
    var _instanceRef$current = instanceRef.current,
        flatColumns = _instanceRef$current.flatColumns,
        userFilterTypes = _instanceRef$current.userFilterTypes;
    var column = flatColumns.find(function (d) {
      return d.id === columnId;
    });

    if (!column) {
      throw new Error("React-Table: Could not find a column with id: ".concat(columnId));
    }

    var filterMethod = getFilterMethod(column.filter, userFilterTypes || {}, filterTypes);
    var newFilter = functionalUpdate(filterValue, state.filters[columnId]); //

    if (shouldAutoRemove(filterMethod.autoRemove, newFilter)) {
      var _state$filters = state.filters,
          remove = _state$filters[columnId],
          newFilters = _objectWithoutProperties(_state$filters, [columnId].map(_toPropertyKey));

      return _objectSpread2({}, state, {
        filters: newFilters
      });
    }

    return _objectSpread2({}, state, {
      filters: _objectSpread2({}, state.filters, _defineProperty({}, columnId, newFilter))
    });
  }

  if (action.type === actions.setAllFilters) {
    var filters = action.filters;
    var _instanceRef$current2 = instanceRef.current,
        _flatColumns = _instanceRef$current2.flatColumns,
        _userFilterTypes = _instanceRef$current2.filterTypes;

    var _newFilters = functionalUpdate(filters, state.filters); // Filter out undefined values


    Object.keys(_newFilters).forEach(function (id) {
      var newFilter = _newFilters[id];

      var column = _flatColumns.find(function (d) {
        return d.id === id;
      });

      var filterMethod = getFilterMethod(column.filter, _userFilterTypes || {}, filterTypes);

      if (shouldAutoRemove(filterMethod.autoRemove, newFilter)) {
        delete _newFilters[id];
      }
    });
    return _objectSpread2({}, state, {
      filters: _newFilters
    });
  }
}

function useInstance$2(instance) {
  var data = instance.data,
      rows = instance.rows,
      flatRows = instance.flatRows,
      flatColumns = instance.flatColumns,
      userFilterTypes = instance.filterTypes,
      manualFilters = instance.manualFilters,
      _instance$defaultCanF = instance.defaultCanFilter,
      defaultCanFilter = _instance$defaultCanF === void 0 ? false : _instance$defaultCanF,
      disableFilters = instance.disableFilters,
      filters = instance.state.filters,
      dispatch = instance.dispatch,
      _instance$autoResetFi = instance.autoResetFilters,
      autoResetFilters = _instance$autoResetFi === void 0 ? true : _instance$autoResetFi;
  var preFilteredRows = rows;
  var preFilteredFlatRows = flatRows;

  var setFilter = function setFilter(columnId, filterValue) {
    dispatch({
      type: actions.setFilter,
      columnId: columnId,
      filterValue: filterValue
    });
  };

  var setAllFilters = function setAllFilters(filters) {
    dispatch({
      type: actions.setAllFilters,
      filters: filters
    });
  };

  flatColumns.forEach(function (column) {
    var id = column.id,
        accessor = column.accessor,
        columnDefaultCanFilter = column.defaultCanFilter,
        columnDisableFilters = column.disableFilters; // Determine if a column is filterable

    column.canFilter = accessor ? getFirstDefined(columnDisableFilters === true ? false : undefined, disableFilters === true ? false : undefined, true) : getFirstDefined(columnDefaultCanFilter, defaultCanFilter, false); // Provide the column a way of updating the filter value

    column.setFilter = function (val) {
      return setFilter(column.id, val);
    }; // Provide the current filter value to the column for
    // convenience


    column.filterValue = filters[id];
  }); // TODO: Create a filter cache for incremental high speed multi-filtering
  // This gets pretty complicated pretty fast, since you have to maintain a
  // cache for each row group (top-level rows, and each row's recursive subrows)
  // This would make multi-filtering a lot faster though. Too far?

  var _React$useMemo = React.useMemo(function () {
    if (manualFilters || !Object.keys(filters).length) {
      return {
        filteredRows: rows,
        filteredFlatRows: flatRows
      };
    }

    var filteredFlatRows = []; // Filters top level and nested rows

    var filterRows = function filterRows(rows) {
      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var filteredRows = rows;
      filteredRows = Object.entries(filters).reduce(function (filteredSoFar, _ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            columnId = _ref2[0],
            filterValue = _ref2[1];

        // Find the filters column
        var column = flatColumns.find(function (d) {
          return d.id === columnId;
        });

        if (!column) {
          return filteredSoFar;
        }

        if (depth === 0) {
          column.preFilteredRows = filteredSoFar;
        }

        var filterMethod = getFilterMethod(column.filter, userFilterTypes || {}, filterTypes);

        if (!filterMethod) {
          console.warn("Could not find a valid 'column.filter' for column with the ID: ".concat(column.id, "."));
          return filteredSoFar;
        } // Pass the rows, id, filterValue and column to the filterMethod
        // to get the filtered rows back


        column.filteredRows = filterMethod(filteredSoFar, columnId, filterValue, column);
        return column.filteredRows;
      }, rows); // Apply the filter to any subRows
      // We technically could do this recursively in the above loop,
      // but that would severely hinder the API for the user, since they
      // would be required to do that recursion in some scenarios

      filteredRows = filteredRows.map(function (row) {
        filteredFlatRows.push(row);

        if (!row.subRows) {
          return row;
        }

        return _objectSpread2({}, row, {
          subRows: row.subRows && row.subRows.length > 0 ? filterRows(row.subRows, depth + 1) : row.subRows
        });
      });
      return filteredRows;
    };

    return {
      filteredRows: filterRows(rows),
      filteredFlatRows: filteredFlatRows
    };
  }, [manualFilters, filters, rows, flatRows, flatColumns, userFilterTypes]),
      filteredRows = _React$useMemo.filteredRows,
      filteredFlatRows = _React$useMemo.filteredFlatRows;

  React.useMemo(function () {
    // Now that each filtered column has it's partially filtered rows,
    // lets assign the final filtered rows to all of the other columns
    var nonFilteredColumns = flatColumns.filter(function (column) {
      return !Object.keys(filters).includes(column.id);
    }); // This essentially enables faceted filter options to be built easily
    // using every column's preFilteredRows value

    nonFilteredColumns.forEach(function (column) {
      column.preFilteredRows = filteredRows;
      column.filteredRows = filteredRows;
    });
  }, [filteredRows, filters, flatColumns]);
  var getAutoResetFilters = useGetLatest(autoResetFilters);
  useMountedLayoutEffect(function () {
    if (getAutoResetFilters()) {
      dispatch({
        type: actions.resetFilters
      });
    }
  }, [dispatch, manualFilters ? null : data]);
  return _objectSpread2({}, instance, {
    setFilter: setFilter,
    setAllFilters: setAllFilters,
    preFilteredRows: preFilteredRows,
    preFilteredFlatRows: preFilteredFlatRows,
    rows: filteredRows,
    flatRows: filteredFlatRows
  });
}

function shouldAutoRemove(autoRemove, value) {
  return autoRemove ? autoRemove(value) : typeof value === 'undefined';
}

function getFilterMethod(filter, userFilterTypes, filterTypes) {
  return isFunction(filter) || userFilterTypes[filter] || filterTypes[filter] || filterTypes.text;
}

function sum(values, rows) {
  return values.reduce(function (sum, next) {
    return sum + next;
  }, 0);
}
function average(values, rows) {
  return Math.round(sum(values) / values.length * 100) / 100;
}
function median(values) {
  values = values.length ? values : [0];
  var min = Math.min.apply(Math, _toConsumableArray(values));
  var max = Math.max.apply(Math, _toConsumableArray(values));
  return (min + max) / 2;
}
function uniqueCount(values) {
  return new Set(values).size;
}
function count(values) {
  return values.length;
}

var aggregations = /*#__PURE__*/Object.freeze({
  __proto__: null,
  sum: sum,
  average: average,
  median: median,
  uniqueCount: uniqueCount,
  count: count
});

actions.resetGroupBy = 'resetGroupBy';
actions.toggleGroupBy = 'toggleGroupBy';
var useGroupBy = function useGroupBy(hooks) {
  hooks.stateReducers.push(reducer$3);
  hooks.flatColumnsDeps.push(function (deps, instance) {
    return [].concat(_toConsumableArray(deps), [instance.state.groupBy]);
  });
  hooks.flatColumns.push(flatColumns);
  hooks.useInstance.push(useInstance$3);
};
useGroupBy.pluginName = 'useGroupBy'; // Reducer

function reducer$3(state, action) {
  if (action.type === actions.init) {
    return _objectSpread2({
      groupBy: []
    }, state);
  }

  if (action.type === actions.resetGroupBy) {
    return _objectSpread2({}, state, {
      groupBy: []
    });
  }

  if (action.type === actions.toggleGroupBy) {
    var columnId = action.columnId,
        toggle = action.toggle;
    var resolvedToggle = typeof toggle !== 'undefined' ? toggle : !state.groupBy.includes(columnId);

    if (resolvedToggle) {
      return _objectSpread2({}, state, {
        groupBy: [].concat(_toConsumableArray(state.groupBy), [columnId])
      });
    }

    return _objectSpread2({}, state, {
      groupBy: state.groupBy.filter(function (d) {
        return d !== columnId;
      })
    });
  }
}

function flatColumns(flatColumns, _ref) {
  var groupBy = _ref.state.groupBy;
  // Sort grouped columns to the start of the column list
  // before the headers are built
  var groupByColumns = groupBy.map(function (g) {
    return flatColumns.find(function (col) {
      return col.id === g;
    });
  });
  var nonGroupByColumns = flatColumns.filter(function (col) {
    return !groupBy.includes(col.id);
  }); // If a groupByBoundary column is found, place the groupBy's after it

  var groupByBoundaryColumnIndex = flatColumns.findIndex(function (column) {
    return column.groupByBoundary;
  }) + 1;
  return [].concat(_toConsumableArray(nonGroupByColumns.slice(0, groupByBoundaryColumnIndex)), _toConsumableArray(groupByColumns), _toConsumableArray(nonGroupByColumns.slice(groupByBoundaryColumnIndex)));
}

var defaultUserAggregations = {};

function useInstance$3(instance) {
  var data = instance.data,
      rows = instance.rows,
      flatRows = instance.flatRows,
      flatColumns = instance.flatColumns,
      flatHeaders = instance.flatHeaders,
      _instance$groupByFn = instance.groupByFn,
      groupByFn = _instance$groupByFn === void 0 ? defaultGroupByFn : _instance$groupByFn,
      manualGroupBy = instance.manualGroupBy,
      defaultCanGroupBy = instance.defaultCanGroupBy,
      disableGroupBy = instance.disableGroupBy,
      _instance$aggregation = instance.aggregations,
      userAggregations = _instance$aggregation === void 0 ? defaultUserAggregations : _instance$aggregation,
      hooks = instance.hooks,
      plugins = instance.plugins,
      groupBy = instance.state.groupBy,
      dispatch = instance.dispatch,
      _instance$autoResetGr = instance.autoResetGroupBy,
      autoResetGroupBy = _instance$autoResetGr === void 0 ? true : _instance$autoResetGr,
      manaulGroupBy = instance.manaulGroupBy;
  ensurePluginOrder(plugins, [], 'useGroupBy', ['useSortBy', 'useExpanded']);
  flatColumns.forEach(function (column) {
    var id = column.id,
        accessor = column.accessor,
        defaultColumnGroupBy = column.defaultGroupBy,
        columnDisableGroupBy = column.disableGroupBy;
    column.isGrouped = groupBy.includes(id);
    column.groupedIndex = groupBy.indexOf(id);
    column.canGroupBy = accessor ? getFirstDefined(columnDisableGroupBy === true ? false : undefined, disableGroupBy === true ? false : undefined, true) : getFirstDefined(defaultColumnGroupBy, defaultCanGroupBy, false);

    if (column.canGroupBy) {
      column.toggleGroupBy = function () {
        return toggleGroupBy(column.id);
      };
    }

    column.Aggregated = column.Aggregated || column.Cell;
  });

  var toggleGroupBy = function toggleGroupBy(columnId, toggle) {
    dispatch({
      type: actions.toggleGroupBy,
      columnId: columnId,
      toggle: toggle
    });
  };

  hooks.getGroupByToggleProps = []; // use reference to avoid memory leak in #1608

  var instanceRef = React.useRef();
  instanceRef.current = instance;
  flatHeaders.forEach(function (header) {
    var canGroupBy = header.canGroupBy;

    header.getGroupByToggleProps = function (props) {
      return mergeProps({
        onClick: canGroupBy ? function (e) {
          e.persist();
          header.toggleGroupBy();
        } : undefined,
        style: {
          cursor: canGroupBy ? 'pointer' : undefined
        },
        title: 'Toggle GroupBy'
      }, applyPropHooks(instanceRef.current.hooks.getGroupByToggleProps, header, instanceRef.current), props);
    };
  });
  hooks.prepareRow.push(function (row) {
    row.cells.forEach(function (cell) {
      // Grouped cells are in the groupBy and the pivot cell for the row
      cell.isGrouped = cell.column.isGrouped && cell.column.id === row.groupByID; // Repeated cells are any columns in the groupBy that are not grouped

      cell.isRepeatedValue = !cell.isGrouped && cell.column.isGrouped; // Aggregated cells are not grouped, not repeated, but still have subRows

      cell.isAggregated = !cell.isGrouped && !cell.isRepeatedValue && row.canExpand;
    });
    return row;
  });

  var _React$useMemo = React.useMemo(function () {
    if (manualGroupBy || !groupBy.length) {
      return [rows, flatRows];
    } // Find the columns that can or are aggregating
    // Uses each column to aggregate rows into a single value


    var aggregateRowsToValues = function aggregateRowsToValues(rows, isAggregated) {
      var values = {};
      flatColumns.forEach(function (column) {
        // Don't aggregate columns that are in the groupBy
        if (groupBy.includes(column.id)) {
          values[column.id] = rows[0] ? rows[0].values[column.id] : null;
          return;
        }

        var columnValues = rows.map(function (d) {
          return d.values[column.id];
        });
        var aggregator = column.aggregate;

        if (Array.isArray(aggregator)) {
          if (aggregator.length !== 2) {
            console.info({
              column: column
            });
            throw new Error("React Table: Complex aggregators must have 2 values, eg. aggregate: ['sum', 'count']. More info above...");
          }

          if (isAggregated) {
            aggregator = aggregator[1];
          } else {
            aggregator = aggregator[0];
          }
        }

        var aggregateFn = typeof aggregator === 'function' ? aggregator : userAggregations[aggregator] || aggregations[aggregator];

        if (aggregateFn) {
          values[column.id] = aggregateFn(columnValues, rows, isAggregated);
        } else if (aggregator) {
          console.info({
            column: column
          });
          throw new Error("React Table: Invalid aggregate option for column listed above");
        } else {
          values[column.id] = null;
        }
      });
      return values;
    };

    var groupedFlatRows = []; // Recursively group the data

    var groupRecursively = function groupRecursively(rows) {
      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var parentPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

      // This is the last level, just return the rows
      if (depth >= groupBy.length) {
        rows.forEach(function (row) {
          row.path = [].concat(_toConsumableArray(parentPath), _toConsumableArray(row.path));
        });
        groupedFlatRows = groupedFlatRows.concat(rows);
        return rows;
      }

      var columnId = groupBy[depth]; // Group the rows together for this level

      var groupedRows = groupByFn(rows, columnId); // Recurse to sub rows before aggregation

      groupedRows = Object.entries(groupedRows).map(function (_ref2, index) {
        var _ref3 = _slicedToArray(_ref2, 2),
            groupByVal = _ref3[0],
            subRows = _ref3[1];

        var path = [].concat(_toConsumableArray(parentPath), ["".concat(columnId, ":").concat(groupByVal)]);
        subRows = groupRecursively(subRows, depth + 1, path);
        var values = aggregateRowsToValues(subRows, depth < groupBy.length);
        var row = {
          isAggregated: true,
          groupByID: columnId,
          groupByVal: groupByVal,
          values: values,
          subRows: subRows,
          depth: depth,
          index: index,
          path: path
        };
        groupedFlatRows.push(row);
        return row;
      });
      return groupedRows;
    };

    var groupedRows = groupRecursively(rows); // Assign the new data

    return [groupedRows, groupedFlatRows];
  }, [manualGroupBy, groupBy, rows, flatRows, flatColumns, userAggregations, groupByFn]),
      _React$useMemo2 = _slicedToArray(_React$useMemo, 2),
      groupedRows = _React$useMemo2[0],
      groupedFlatRows = _React$useMemo2[1];

  var getAutoResetGroupBy = useGetLatest(autoResetGroupBy);
  useMountedLayoutEffect(function () {
    if (getAutoResetGroupBy()) {
      dispatch({
        type: actions.resetGroupBy
      });
    }
  }, [dispatch, manaulGroupBy ? null : data]);
  return _objectSpread2({}, instance, {
    toggleGroupBy: toggleGroupBy,
    rows: groupedRows,
    flatRows: groupedFlatRows,
    preGroupedRows: rows
  });
}

var reSplitAlphaNumeric = /([0-9]+)/gm; // Mixed sorting is slow, but very inclusive of many edge cases.
// It handles numbers, mixed alphanumeric combinations, and even
// null, undefined, and Infinity

var alphanumeric = function alphanumeric(rowA, rowB, columnId) {
  var a = getRowValueByColumnID(rowA, columnId);
  var b = getRowValueByColumnID(rowB, columnId); // Force to strings (or "" for unsupported types)

  a = toString(a);
  b = toString(b); // Split on number groups, but keep the delimiter
  // Then remove falsey split values

  a = a.split(reSplitAlphaNumeric).filter(Boolean);
  b = b.split(reSplitAlphaNumeric).filter(Boolean); // While

  while (a.length && b.length) {
    var aa = a.shift();
    var bb = b.shift();
    var an = parseInt(aa, 10);
    var bn = parseInt(bb, 10);
    var combo = [an, bn].sort(); // Both are string

    if (isNaN(combo[0])) {
      if (aa > bb) {
        return 1;
      }

      if (bb > aa) {
        return -1;
      }

      continue;
    } // One is a string, one is a number


    if (isNaN(combo[1])) {
      return isNaN(an) ? -1 : 1;
    } // Both are numbers


    if (an > bn) {
      return 1;
    }

    if (bn > an) {
      return -1;
    }
  }

  return a.length - b.length;
};
function datetime(rowA, rowB, columnId) {
  var a = getRowValueByColumnID(rowA, columnId);
  var b = getRowValueByColumnID(rowB, columnId);
  a = a.getTime();
  b = b.getTime();
  return compareBasic(a, b);
}
function basic(rowA, rowB, columnId) {
  var a = getRowValueByColumnID(rowA, columnId);
  var b = getRowValueByColumnID(rowB, columnId);
  return compareBasic(a, b);
} // Utils

function compareBasic(a, b) {
  return a === b ? 0 : a > b ? 1 : -1;
}

function getRowValueByColumnID(row, columnId) {
  return row.values[columnId];
}

function toString(a) {
  if (typeof a === 'number') {
    if (isNaN(a) || a === Infinity || a === -Infinity) {
      return '';
    }

    return String(a);
  }

  if (typeof a === 'string') {
    return a;
  }

  return '';
}

var sortTypes = /*#__PURE__*/Object.freeze({
  __proto__: null,
  alphanumeric: alphanumeric,
  datetime: datetime,
  basic: basic
});

actions.resetSortBy = 'resetSortBy';
actions.toggleSortBy = 'toggleSortBy';
actions.clearSortBy = 'clearSortBy';
defaultColumn.sortType = 'alphanumeric';
defaultColumn.sortDescFirst = false;
var useSortBy = function useSortBy(hooks) {
  hooks.stateReducers.push(reducer$4);
  hooks.useInstance.push(useInstance$4);
};
useSortBy.pluginName = 'useSortBy'; // Reducer

function reducer$4(state, action, previousState, instanceRef) {
  if (action.type === actions.init) {
    return _objectSpread2({
      sortBy: []
    }, state);
  }

  if (action.type === actions.resetSortBy) {
    return _objectSpread2({}, state, {
      sortBy: []
    });
  }

  if (action.type === actions.clearSortBy) {
    var sortBy = state.sortBy;
    var newSortBy = sortBy.filter(function (d) {
      return d.id !== action.columnId;
    });
    return _objectSpread2({}, state, {
      sortBy: newSortBy
    });
  }

  if (action.type === actions.toggleSortBy) {
    var columnId = action.columnId,
        desc = action.desc,
        multi = action.multi;
    var _instanceRef$current = instanceRef.current,
        flatColumns = _instanceRef$current.flatColumns,
        disableMultiSort = _instanceRef$current.disableMultiSort,
        disableSortRemove = _instanceRef$current.disableSortRemove,
        disableMultiRemove = _instanceRef$current.disableMultiRemove,
        _instanceRef$current$ = _instanceRef$current.maxMultiSortColCount,
        maxMultiSortColCount = _instanceRef$current$ === void 0 ? Number.MAX_SAFE_INTEGER : _instanceRef$current$;
    var _sortBy = state.sortBy; // Find the column for this columnId

    var column = flatColumns.find(function (d) {
      return d.id === columnId;
    });
    var sortDescFirst = column.sortDescFirst; // Find any existing sortBy for this column

    var existingSortBy = _sortBy.find(function (d) {
      return d.id === columnId;
    });

    var existingIndex = _sortBy.findIndex(function (d) {
      return d.id === columnId;
    });

    var hasDescDefined = typeof desc !== 'undefined' && desc !== null;
    var _newSortBy = []; // What should we do with this sort action?

    var sortAction;

    if (!disableMultiSort && multi) {
      if (existingSortBy) {
        sortAction = 'toggle';
      } else {
        sortAction = 'add';
      }
    } else {
      // Normal mode
      if (existingIndex !== _sortBy.length - 1) {
        sortAction = 'replace';
      } else if (existingSortBy) {
        sortAction = 'toggle';
      } else {
        sortAction = 'replace';
      }
    } // Handle toggle states that will remove the sortBy


    if (sortAction === 'toggle' && // Must be toggling
    !disableSortRemove && // If disableSortRemove, disable in general
    !hasDescDefined && ( // Must not be setting desc
    multi ? !disableMultiRemove : true) && ( // If multi, don't allow if disableMultiRemove
    existingSortBy && // Finally, detect if it should indeed be removed
    existingSortBy.desc && !sortDescFirst || !existingSortBy.desc && sortDescFirst)) {
      sortAction = 'remove';
    }

    if (sortAction === 'replace') {
      _newSortBy = [{
        id: columnId,
        desc: hasDescDefined ? desc : sortDescFirst
      }];
    } else if (sortAction === 'add') {
      _newSortBy = [].concat(_toConsumableArray(_sortBy), [{
        id: columnId,
        desc: hasDescDefined ? desc : sortDescFirst
      }]); // Take latest n columns

      _newSortBy.splice(0, _newSortBy.length - maxMultiSortColCount);
    } else if (sortAction === 'toggle') {
      // This flips (or sets) the
      _newSortBy = _sortBy.map(function (d) {
        if (d.id === columnId) {
          return _objectSpread2({}, d, {
            desc: hasDescDefined ? desc : !existingSortBy.desc
          });
        }

        return d;
      });
    } else if (sortAction === 'remove') {
      _newSortBy = _sortBy.filter(function (d) {
        return d.id !== columnId;
      });
    }

    return _objectSpread2({}, state, {
      sortBy: _newSortBy
    });
  }
}

function useInstance$4(instance) {
  var data = instance.data,
      rows = instance.rows,
      flatColumns = instance.flatColumns,
      _instance$orderByFn = instance.orderByFn,
      orderByFn = _instance$orderByFn === void 0 ? defaultOrderByFn : _instance$orderByFn,
      userSortTypes = instance.sortTypes,
      manualSortBy = instance.manualSortBy,
      defaultCanSort = instance.defaultCanSort,
      disableSortBy = instance.disableSortBy,
      _instance$isMultiSort = instance.isMultiSortEvent,
      isMultiSortEvent = _instance$isMultiSort === void 0 ? function (e) {
    return e.shiftKey;
  } : _instance$isMultiSort,
      flatHeaders = instance.flatHeaders,
      hooks = instance.hooks,
      sortBy = instance.state.sortBy,
      dispatch = instance.dispatch,
      plugins = instance.plugins,
      _instance$autoResetSo = instance.autoResetSortBy,
      autoResetSortBy = _instance$autoResetSo === void 0 ? true : _instance$autoResetSo;
  ensurePluginOrder(plugins, ['useFilters'], 'useSortBy', []); // Add custom hooks

  hooks.getSortByToggleProps = []; // Updates sorting based on a columnId, desc flag and multi flag

  var toggleSortBy = function toggleSortBy(columnId, desc, multi) {
    dispatch({
      type: actions.toggleSortBy,
      columnId: columnId,
      desc: desc,
      multi: multi
    });
  }; // use reference to avoid memory leak in #1608


  var getInstance = useGetLatest(instance); // Add the getSortByToggleProps method to columns and headers

  flatHeaders.forEach(function (column) {
    var accessor = column.accessor,
        defaultColumnCanSort = column.canSort,
        columnDisableSortBy = column.disableSortBy,
        id = column.id;
    var canSort = accessor ? getFirstDefined(columnDisableSortBy === true ? false : undefined, disableSortBy === true ? false : undefined, true) : getFirstDefined(defaultCanSort, defaultColumnCanSort, false);
    column.canSort = canSort;

    if (column.canSort) {
      column.toggleSortBy = function (desc, multi) {
        return toggleSortBy(column.id, desc, multi);
      };

      column.clearSortBy = function () {
        dispatch({
          type: actions.clearSortBy,
          columnId: column.id
        });
      };
    }

    column.getSortByToggleProps = function (props) {
      return mergeProps({
        onClick: canSort ? function (e) {
          e.persist();
          column.toggleSortBy(undefined, !getInstance().disableMultiSort && isMultiSortEvent(e));
        } : undefined,
        style: {
          cursor: canSort ? 'pointer' : undefined
        },
        title: canSort ? 'Toggle SortBy' : undefined
      }, applyPropHooks(getInstance().hooks.getSortByToggleProps, column, getInstance()), props);
    };

    var columnSort = sortBy.find(function (d) {
      return d.id === id;
    });
    column.isSorted = !!columnSort;
    column.sortedIndex = sortBy.findIndex(function (d) {
      return d.id === id;
    });
    column.isSortedDesc = column.isSorted ? columnSort.desc : undefined;
  });
  var sortedRows = React.useMemo(function () {
    if (manualSortBy || !sortBy.length) {
      return rows;
    } // Filter out sortBys that correspond to non existing columns


    var availableSortBy = sortBy.filter(function (sort) {
      return flatColumns.find(function (col) {
        return col.id === sort.id;
      });
    });

    var sortData = function sortData(rows) {
      // Use the orderByFn to compose multiple sortBy's together.
      // This will also perform a stable sorting using the row index
      // if needed.
      var sortedData = orderByFn(rows, availableSortBy.map(function (sort) {
        // Support custom sorting methods for each column
        var column = flatColumns.find(function (d) {
          return d.id === sort.id;
        });

        if (!column) {
          throw new Error("React-Table: Could not find a column with id: ".concat(sort.id, " while sorting"));
        }

        var sortType = column.sortType; // Look up sortBy functions in this order:
        // column function
        // column string lookup on user sortType
        // column string lookup on built-in sortType
        // default function
        // default string lookup on user sortType
        // default string lookup on built-in sortType

        var sortMethod = isFunction(sortType) || (userSortTypes || {})[sortType] || sortTypes[sortType];

        if (!sortMethod) {
          throw new Error("React-Table: Could not find a valid sortType of '".concat(sortType, "' for column '").concat(sort.id, "'."));
        } // Return the correct sortFn.
        // This function should always return in ascending order


        return function (a, b) {
          return sortMethod(a, b, sort.id);
        };
      }), // Map the directions
      availableSortBy.map(function (sort) {
        // Detect and use the sortInverted option
        var column = flatColumns.find(function (d) {
          return d.id === sort.id;
        });

        if (column && column.sortInverted) {
          return sort.desc;
        }

        return !sort.desc;
      })); // If there are sub-rows, sort them

      sortedData.forEach(function (row) {
        if (!row.subRows || row.subRows.length <= 1) {
          return;
        }

        row.subRows = sortData(row.subRows);
      });
      return sortedData;
    };

    return sortData(rows);
  }, [manualSortBy, sortBy, rows, flatColumns, orderByFn, userSortTypes]);
  var getAutoResetSortBy = useGetLatest(autoResetSortBy);
  useMountedLayoutEffect(function () {
    if (getAutoResetSortBy()) {
      dispatch({
        type: actions.resetSortBy
      });
    }
  }, [manualSortBy ? null : data]);
  return _objectSpread2({}, instance, {
    toggleSortBy: toggleSortBy,
    rows: sortedRows,
    preSortedRows: rows
  });
}

var pluginName = 'usePagination'; // Actions

actions.resetPage = 'resetPage';
actions.gotoPage = 'gotoPage';
actions.setPageSize = 'setPageSize';
var usePagination = function usePagination(hooks) {
  hooks.stateReducers.push(reducer$5);
  hooks.useInstance.push(useInstance$5);
};
usePagination.pluginName = pluginName;

function reducer$5(state, action, previousState, instanceRef) {
  if (action.type === actions.init) {
    return _objectSpread2({
      pageSize: 10,
      pageIndex: 0
    }, state);
  }

  if (action.type === actions.resetPage) {
    return _objectSpread2({}, state, {
      pageIndex: 0
    });
  }

  if (action.type === actions.gotoPage) {
    var pageCount = instanceRef.current.pageCount;
    var newPageIndex = functionalUpdate(action.pageIndex, state.pageIndex);

    if (newPageIndex < 0 || newPageIndex > pageCount - 1) {
      return state;
    }

    return _objectSpread2({}, state, {
      pageIndex: newPageIndex
    });
  }

  if (action.type === actions.setPageSize) {
    var pageSize = action.pageSize;
    var topRowIndex = state.pageSize * state.pageIndex;
    var pageIndex = Math.floor(topRowIndex / pageSize);
    return _objectSpread2({}, state, {
      pageIndex: pageIndex,
      pageSize: pageSize
    });
  }
}

function useInstance$5(instance) {
  var rows = instance.rows,
      _instance$autoResetPa = instance.autoResetPage,
      autoResetPage = _instance$autoResetPa === void 0 ? true : _instance$autoResetPa,
      _instance$manualExpan = instance.manualExpandedKey,
      manualExpandedKey = _instance$manualExpan === void 0 ? 'expanded' : _instance$manualExpan,
      plugins = instance.plugins,
      userPageCount = instance.pageCount,
      _instance$paginateExp = instance.paginateExpandedRows,
      paginateExpandedRows = _instance$paginateExp === void 0 ? true : _instance$paginateExp,
      _instance$expandSubRo = instance.expandSubRows,
      expandSubRows = _instance$expandSubRo === void 0 ? true : _instance$expandSubRo,
      _instance$state = instance.state,
      pageSize = _instance$state.pageSize,
      pageIndex = _instance$state.pageIndex,
      expanded = _instance$state.expanded,
      filters = _instance$state.filters,
      groupBy = _instance$state.groupBy,
      sortBy = _instance$state.sortBy,
      dispatch = instance.dispatch,
      data = instance.data,
      manualPagination = instance.manualPagination,
      manualFilters = instance.manualFilters,
      manualGroupBy = instance.manualGroupBy,
      manualSortBy = instance.manualSortBy;
  ensurePluginOrder(plugins, ['useFilters', 'useGroupBy', 'useSortBy', 'useExpanded'], 'usePagination', []);
  var getAutoResetPage = useGetLatest(autoResetPage);
  useMountedLayoutEffect(function () {
    if (getAutoResetPage()) {
      dispatch({
        type: actions.resetPage
      });
    }
  }, [dispatch, manualPagination ? null : data, manualPagination || manualFilters ? null : filters, manualPagination || manualGroupBy ? null : groupBy, manualPagination || manualSortBy ? null : sortBy]);
  var pageCount = manualPagination ? userPageCount : Math.ceil(rows.length / pageSize);
  var pageOptions = React.useMemo(function () {
    return pageCount > 0 ? _toConsumableArray(new Array(pageCount)).map(function (d, i) {
      return i;
    }) : [];
  }, [pageCount]);
  var page = React.useMemo(function () {
    var page;

    if (manualPagination) {
      page = rows;
    } else {
      var pageStart = pageSize * pageIndex;
      var pageEnd = pageStart + pageSize;
      page = rows.slice(pageStart, pageEnd);
    }

    if (paginateExpandedRows) {
      return page;
    }

    return expandRows(page, {
      manualExpandedKey: manualExpandedKey,
      expanded: expanded,
      expandSubRows: expandSubRows
    });
  }, [expandSubRows, expanded, manualExpandedKey, manualPagination, pageIndex, pageSize, paginateExpandedRows, rows]);
  var canPreviousPage = pageIndex > 0;
  var canNextPage = pageCount === -1 || pageIndex < pageCount - 1;
  var gotoPage = React.useCallback(function (pageIndex) {
    dispatch({
      type: actions.gotoPage,
      pageIndex: pageIndex
    });
  }, [dispatch]);
  var previousPage = React.useCallback(function () {
    return gotoPage(function (old) {
      return old - 1;
    });
  }, [gotoPage]);
  var nextPage = React.useCallback(function () {
    return gotoPage(function (old) {
      return old + 1;
    });
  }, [gotoPage]);
  var setPageSize = React.useCallback(function (pageSize) {
    dispatch({
      type: actions.setPageSize,
      pageSize: pageSize
    });
  }, [dispatch]);
  return _objectSpread2({}, instance, {
    pageOptions: pageOptions,
    pageCount: pageCount,
    page: page,
    canPreviousPage: canPreviousPage,
    canNextPage: canNextPage,
    gotoPage: gotoPage,
    previousPage: previousPage,
    nextPage: nextPage,
    setPageSize: setPageSize,
    pageIndex: pageIndex,
    pageSize: pageSize
  });
}

var pluginName$1 = 'useRowSelect'; // Actions

actions.resetSelectedRows = 'resetSelectedRows';
actions.toggleRowSelectedAll = 'toggleRowSelectedAll';
actions.toggleRowSelected = 'toggleRowSelected';
var useRowSelect = function useRowSelect(hooks) {
  hooks.getToggleRowSelectedProps = [];
  hooks.getToggleAllRowsSelectedProps = [];
  hooks.stateReducers.push(reducer$6);
  hooks.useRows.push(useRows);
  hooks.useInstance.push(useInstance$6);
};
useRowSelect.pluginName = pluginName$1;

function reducer$6(state, action, previousState, instanceRef) {
  if (action.type === actions.init) {
    return _objectSpread2({
      selectedRowPaths: new Set()
    }, state);
  }

  if (action.type === actions.resetSelectedRows) {
    return _objectSpread2({}, state, {
      selectedRowPaths: new Set()
    });
  }

  if (action.type === actions.toggleRowSelectedAll) {
    var selected = action.selected;
    var _instanceRef$current = instanceRef.current,
        isAllRowsSelected = _instanceRef$current.isAllRowsSelected,
        flatRowPaths = _instanceRef$current.flatRowPaths;
    var selectAll = typeof selected !== 'undefined' ? selected : !isAllRowsSelected;
    return _objectSpread2({}, state, {
      selectedRowPaths: selectAll ? new Set(flatRowPaths) : new Set()
    });
  }

  if (action.type === actions.toggleRowSelected) {
    var path = action.path,
        _selected = action.selected;
    var _flatRowPaths = instanceRef.current.flatRowPaths;
    var key = path.join('.');
    var childRowPrefixKey = [key, '.'].join(''); // Join the paths of deep rows
    // to make a key, then manage all of the keys
    // in a flat object

    var exists = state.selectedRowPaths.has(key);
    var shouldExist = typeof set !== 'undefined' ? _selected : !exists;
    var newSelectedRowPaths = new Set(state.selectedRowPaths);

    if (!exists && shouldExist) {
      _flatRowPaths.forEach(function (rowPath) {
        if (rowPath === key || rowPath.startsWith(childRowPrefixKey)) {
          newSelectedRowPaths.add(rowPath);
        }
      });
    } else if (exists && !shouldExist) {
      _flatRowPaths.forEach(function (rowPath) {
        if (rowPath === key || rowPath.startsWith(childRowPrefixKey)) {
          newSelectedRowPaths.delete(rowPath);
        }
      });
    } else {
      return state;
    }

    var updateParentRow = function updateParentRow(selectedRowPaths, path) {
      var parentPath = path.slice(0, path.length - 1);
      var parentKey = parentPath.join('.');
      var selected = _flatRowPaths.filter(function (rowPath) {
        var path = rowPath;
        return path !== parentKey && path.startsWith(parentKey) && !selectedRowPaths.has(path);
      }).length === 0;

      if (selected) {
        selectedRowPaths.add(parentKey);
      } else {
        selectedRowPaths.delete(parentKey);
      }

      if (parentPath.length > 1) updateParentRow(selectedRowPaths, parentPath);
    }; // If the row is a subRow update
    // its parent row to reflect changes


    if (path.length > 1) updateParentRow(newSelectedRowPaths, path);
    return _objectSpread2({}, state, {
      selectedRowPaths: newSelectedRowPaths
    });
  }
}

function useRows(rows, instance) {
  var selectedRowPaths = instance.state.selectedRowPaths;
  instance.selectedFlatRows = React.useMemo(function () {
    var selectedFlatRows = [];
    rows.forEach(function (row) {
      row.isSelected = getRowIsSelected(row, selectedRowPaths);

      if (row.isSelected) {
        selectedFlatRows.push(row);
      }
    });
    return selectedFlatRows;
  }, [rows, selectedRowPaths]);
  return rows;
}

function useInstance$6(instance) {
  var data = instance.data,
      hooks = instance.hooks,
      _instance$manualRowSe = instance.manualRowSelectedKey,
      manualRowSelectedKey = _instance$manualRowSe === void 0 ? 'isSelected' : _instance$manualRowSe,
      plugins = instance.plugins,
      flatRows = instance.flatRows,
      _instance$autoResetSe = instance.autoResetSelectedRows,
      autoResetSelectedRows = _instance$autoResetSe === void 0 ? true : _instance$autoResetSe,
      selectedRowPaths = instance.state.selectedRowPaths,
      dispatch = instance.dispatch;
  ensurePluginOrder(plugins, ['useFilters', 'useGroupBy', 'useSortBy'], 'useRowSelect', []);
  var flatRowPaths = flatRows.map(function (d) {
    return d.path.join('.');
  });
  var isAllRowsSelected = !!flatRowPaths.length && !!selectedRowPaths.size;

  if (isAllRowsSelected) {
    if (flatRowPaths.some(function (d) {
      return !selectedRowPaths.has(d);
    })) {
      isAllRowsSelected = false;
    }
  }

  var getAutoResetSelectedRows = useGetLatest(autoResetSelectedRows);
  useMountedLayoutEffect(function () {
    if (getAutoResetSelectedRows()) {
      dispatch({
        type: actions.resetSelectedRows
      });
    }
  }, [dispatch, data]);

  var toggleRowSelectedAll = function toggleRowSelectedAll(selected) {
    return dispatch({
      type: actions.toggleRowSelectedAll,
      selected: selected
    });
  };

  var toggleRowSelected = function toggleRowSelected(path, selected) {
    return dispatch({
      type: actions.toggleRowSelected,
      path: path,
      selected: selected
    });
  }; // use reference to avoid memory leak in #1608


  var instanceRef = React.useRef();
  instanceRef.current = instance;

  var getToggleAllRowsSelectedProps = function getToggleAllRowsSelectedProps(props) {
    return mergeProps({
      onChange: function onChange(e) {
        toggleRowSelectedAll(e.target.checked);
      },
      style: {
        cursor: 'pointer'
      },
      checked: isAllRowsSelected,
      title: 'Toggle All Rows Selected'
    }, applyPropHooks(instanceRef.current.hooks.getToggleAllRowsSelectedProps, instanceRef.current), props);
  };

  hooks.prepareRow.push(function (row) {
    row.toggleRowSelected = function (set) {
      return toggleRowSelected(row.path, set);
    };

    row.getToggleRowSelectedProps = function (props) {
      var checked = false;

      if (row.original && row.original[manualRowSelectedKey]) {
        checked = true;
      } else {
        checked = row.isSelected;
      }

      return mergeProps({
        onChange: function onChange(e) {
          row.toggleRowSelected(e.target.checked);
        },
        style: {
          cursor: 'pointer'
        },
        checked: checked,
        title: 'Toggle Row Selected'
      }, applyPropHooks(instanceRef.current.hooks.getToggleRowSelectedProps, row, instanceRef.current), props);
    };

    return row;
  });
  return _objectSpread2({}, instance, {
    flatRowPaths: flatRowPaths,
    toggleRowSelected: toggleRowSelected,
    toggleRowSelectedAll: toggleRowSelectedAll,
    getToggleAllRowsSelectedProps: getToggleAllRowsSelectedProps,
    isAllRowsSelected: isAllRowsSelected
  });
}

function getRowIsSelected(row, selectedRowPaths) {
  if (row.isAggregated) {
    return row.subRows.every(function (subRow) {
      return getRowIsSelected(subRow, selectedRowPaths);
    });
  }

  return selectedRowPaths.has(row.path.join('.'));
}

actions.setRowState = 'setRowState';
actions.resetRowState = 'resetRowState';
var useRowState = function useRowState(hooks) {
  hooks.stateReducers.push(reducer$7);
  hooks.useInstance.push(useInstance$7);
};
useRowState.pluginName = 'useRowState';

function reducer$7(state, action) {
  if (action.type === actions.init) {
    return _objectSpread2({
      rowState: {}
    }, state);
  }

  if (action.type === actions.resetRowState) {
    return _objectSpread2({}, state, {
      rowState: {}
    });
  }

  if (action.type === actions.setRowState) {
    var path = action.path,
        value = action.value;
    var pathKey = path.join('.');
    return _objectSpread2({}, state, {
      rowState: _objectSpread2({}, state.rowState, _defineProperty({}, pathKey, functionalUpdate(value, state.rowState[pathKey] || {})))
    });
  }
}

function useInstance$7(instance) {
  var hooks = instance.hooks,
      initialRowStateAccessor = instance.initialRowStateAccessor,
      _instance$autoResetRo = instance.autoResetRowState,
      autoResetRowState = _instance$autoResetRo === void 0 ? true : _instance$autoResetRo,
      rowState = instance.state.rowState,
      data = instance.data,
      dispatch = instance.dispatch;
  var setRowState = React.useCallback(function (path, value, columnId) {
    return dispatch({
      type: actions.setRowState,
      path: path,
      value: value,
      columnId: columnId
    });
  }, [dispatch]);
  var setCellState = React.useCallback(function (rowPath, columnId, value) {
    return setRowState(rowPath, function (old) {
      return _objectSpread2({}, old, {
        cellState: _objectSpread2({}, old.cellState, _defineProperty({}, columnId, functionalUpdate(value, (old.cellState || {})[columnId] || {})))
      });
    }, columnId);
  }, [setRowState]);
  var getAutoResetRowState = useGetLatest(autoResetRowState);
  useMountedLayoutEffect(function () {
    if (getAutoResetRowState()) {
      dispatch({
        type: actions.resetRowState
      });
    }
  }, [data]);
  hooks.prepareRow.push(function (row) {
    var pathKey = row.path.join('.');

    if (row.original) {
      row.state = (typeof rowState[pathKey] !== 'undefined' ? rowState[pathKey] : initialRowStateAccessor && initialRowStateAccessor(row)) || {};

      row.setState = function (updater) {
        return setRowState(row.path, updater);
      };

      row.cells.forEach(function (cell) {
        cell.state = row.state.cellState || {};

        cell.setState = function (updater) {
          return setCellState(row.path, cell.column.id, updater);
        };
      });
    }

    return row;
  });
  return _objectSpread2({}, instance, {
    setRowState: setRowState,
    setCellState: setCellState
  });
}

actions.resetColumnOrder = 'resetColumnOrder';
actions.setColumnOrder = 'setColumnOrder';
var useColumnOrder = function useColumnOrder(hooks) {
  hooks.stateReducers.push(reducer$8);
  hooks.flatColumnsDeps.push(function (deps, instance) {
    return [].concat(_toConsumableArray(deps), [instance.state.columnOrder]);
  });
  hooks.flatColumns.push(flatColumns$1);
  hooks.useInstance.push(useInstance$8);
};
useColumnOrder.pluginName = 'useColumnOrder';

function reducer$8(state, action) {
  if (action.type === actions.init) {
    return _objectSpread2({
      columnOrder: []
    }, state);
  }

  if (action.type === actions.resetColumnOrder) {
    return _objectSpread2({}, state, {
      columnOrder: []
    });
  }

  if (action.type === actions.setColumnOrder) {
    return _objectSpread2({}, state, {
      columnOrder: functionalUpdate(action.columnOrder, state.columnOrder)
    });
  }
}

function flatColumns$1(columns, instance) {
  var columnOrder = instance.state.columnOrder; // If there is no order, return the normal columns

  if (!columnOrder || !columnOrder.length) {
    return columns;
  }

  var columnOrderCopy = _toConsumableArray(columnOrder); // If there is an order, make a copy of the columns


  var columnsCopy = _toConsumableArray(columns); // And make a new ordered array of the columns


  var columnsInOrder = []; // Loop over the columns and place them in order into the new array

  var _loop = function _loop() {
    var targetColumnId = columnOrderCopy.shift();
    var foundIndex = columnsCopy.findIndex(function (d) {
      return d.id === targetColumnId;
    });

    if (foundIndex > -1) {
      columnsInOrder.push(columnsCopy.splice(foundIndex, 1)[0]);
    }
  };

  while (columnsCopy.length && columnOrderCopy.length) {
    _loop();
  } // If there are any columns left, add them to the end


  return [].concat(columnsInOrder, _toConsumableArray(columnsCopy));
}

function useInstance$8(instance) {
  var dispatch = instance.dispatch;
  var setColumnOrder = React.useCallback(function (columnOrder) {
    return dispatch({
      type: actions.setColumnOrder,
      columnOrder: columnOrder
    });
  }, [dispatch]);
  return _objectSpread2({}, instance, {
    setColumnOrder: setColumnOrder
  });
}

defaultColumn.canResize = true; // Actions

actions.columnStartResizing = 'columnStartResizing';
actions.columnResizing = 'columnResizing';
actions.columnDoneResizing = 'columnDoneResizing';
var useResizeColumns = function useResizeColumns(hooks) {
  hooks.stateReducers.push(reducer$9);
  hooks.useInstanceBeforeDimensions.push(useInstanceBeforeDimensions$1);
};
useResizeColumns.pluginName = 'useResizeColumns';

function reducer$9(state, action) {
  if (action.type === actions.init) {
    return _objectSpread2({
      columnResizing: {
        columnWidths: {}
      }
    }, state);
  }

  if (action.type === actions.columnStartResizing) {
    var clientX = action.clientX,
        columnId = action.columnId,
        columnWidth = action.columnWidth,
        headerIdWidths = action.headerIdWidths;
    return _objectSpread2({}, state, {
      columnResizing: _objectSpread2({}, state.columnResizing, {
        startX: clientX,
        headerIdWidths: headerIdWidths,
        columnWidth: columnWidth,
        isResizingColumn: columnId
      })
    });
  }

  if (action.type === actions.columnResizing) {
    var _clientX = action.clientX;
    var _state$columnResizing = state.columnResizing,
        startX = _state$columnResizing.startX,
        _columnWidth = _state$columnResizing.columnWidth,
        _headerIdWidths = _state$columnResizing.headerIdWidths;
    var deltaX = _clientX - startX;
    var percentageDeltaX = deltaX / _columnWidth;
    var newColumnWidths = {};

    _headerIdWidths.forEach(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          headerId = _ref2[0],
          headerWidth = _ref2[1];

      newColumnWidths[headerId] = Math.max(headerWidth + headerWidth * percentageDeltaX, 0);
    });

    return _objectSpread2({}, state, {
      columnResizing: _objectSpread2({}, state.columnResizing, {
        columnWidths: _objectSpread2({}, state.columnResizing.columnWidths, {}, newColumnWidths)
      })
    });
  }

  if (action.type === actions.columnDoneResizing) {
    return _objectSpread2({}, state, {
      columnResizing: _objectSpread2({}, state.columnResizing, {
        startX: null,
        isResizingColumn: null
      })
    });
  }
}

var useInstanceBeforeDimensions$1 = function useInstanceBeforeDimensions(instance) {
  instance.hooks.getResizerProps = [];
  var flatHeaders = instance.flatHeaders,
      disableResizing = instance.disableResizing,
      getHeaderProps = instance.hooks.getHeaderProps,
      columnResizing = instance.state.columnResizing,
      dispatch = instance.dispatch;
  getHeaderProps.push(function () {
    return {
      style: {
        position: 'relative'
      }
    };
  });

  var _onMouseDown = function onMouseDown(e, header) {
    var headersToResize = getLeafHeaders(header);
    var headerIdWidths = headersToResize.map(function (d) {
      return [d.id, d.totalWidth];
    });
    var clientX = e.clientX;

    var onMouseMove = function onMouseMove(e) {
      var clientX = e.clientX;
      dispatch({
        type: actions.columnResizing,
        clientX: clientX
      });
    };

    var onMouseUp = function onMouseUp(e) {
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
      dispatch({
        type: actions.columnDoneResizing
      });
    };

    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
    dispatch({
      type: actions.columnStartResizing,
      columnId: header.id,
      columnWidth: header.totalWidth,
      headerIdWidths: headerIdWidths,
      clientX: clientX
    });
  }; // use reference to avoid memory leak in #1608


  var getInstance = useGetLatest(instance);
  flatHeaders.forEach(function (header) {
    var canResize = getFirstDefined(header.disableResizing === true ? false : undefined, disableResizing === true ? false : undefined, true);
    header.canResize = canResize;
    header.width = columnResizing.columnWidths[header.id] || header.width;
    header.isResizing = columnResizing.isResizingColumn === header.id;

    if (canResize) {
      header.getResizerProps = function (userProps) {
        return mergeProps({
          onMouseDown: function onMouseDown(e) {
            return e.persist() || _onMouseDown(e, header);
          },
          style: {
            cursor: 'ew-resize'
          },
          draggable: false
        }, applyPropHooks(getInstance().hooks.getResizerProps, header, getInstance()), userProps);
      };
    }
  });
  return instance;
};

function getLeafHeaders(header) {
  var leafHeaders = [];

  var recurseHeader = function recurseHeader(header) {
    if (header.columns && header.columns.length) {
      header.columns.map(recurseHeader);
    }

    leafHeaders.push(header);
  };

  recurseHeader(header);
  return leafHeaders;
}

var useAbsoluteLayout = function useAbsoluteLayout(hooks) {
  hooks.useInstance.push(useInstance$9);
};
useAbsoluteLayout.pluginName = 'useAbsoluteLayout';

var useInstance$9 = function useInstance(instance) {
  var totalColumnsWidth = instance.totalColumnsWidth,
      _instance$hooks = instance.hooks,
      getRowProps = _instance$hooks.getRowProps,
      getTableBodyProps = _instance$hooks.getTableBodyProps,
      getHeaderGroupProps = _instance$hooks.getHeaderGroupProps,
      getHeaderProps = _instance$hooks.getHeaderProps,
      getCellProps = _instance$hooks.getCellProps;
  var rowStyles = {
    style: {
      position: 'relative',
      width: "".concat(totalColumnsWidth, "px")
    }
  };
  getTableBodyProps.push(function () {
    return rowStyles;
  });
  getRowProps.push(function () {
    return rowStyles;
  });
  getHeaderGroupProps.push(function () {
    return rowStyles;
  }); // Calculating column/cells widths

  var cellStyles = {
    position: 'absolute',
    top: 0
  };
  getHeaderProps.push(function (header) {
    return {
      style: _objectSpread2({}, cellStyles, {
        left: "".concat(header.totalLeft, "px"),
        width: "".concat(header.totalWidth, "px")
      })
    };
  });
  getCellProps.push(function (cell) {
    return {
      style: _objectSpread2({}, cellStyles, {
        left: "".concat(cell.column.totalLeft, "px"),
        width: "".concat(cell.column.totalWidth, "px")
      })
    };
  });
  return instance;
};

var useBlockLayout = function useBlockLayout(hooks) {
  hooks.useInstance.push(useInstance$a);
};
useBlockLayout.pluginName = 'useBlockLayout';

var useInstance$a = function useInstance(instance) {
  var totalColumnsWidth = instance.totalColumnsWidth,
      _instance$hooks = instance.hooks,
      getRowProps = _instance$hooks.getRowProps,
      getHeaderGroupProps = _instance$hooks.getHeaderGroupProps,
      getHeaderProps = _instance$hooks.getHeaderProps,
      getCellProps = _instance$hooks.getCellProps;
  var rowStyles = {
    style: {
      display: 'flex',
      width: "".concat(totalColumnsWidth, "px")
    }
  };
  getRowProps.push(function () {
    return rowStyles;
  });
  getHeaderGroupProps.push(function () {
    return rowStyles;
  });
  var cellStyles = {
    display: 'inline-block',
    boxSizing: 'border-box'
  };
  getHeaderProps.push(function (header) {
    return {
      style: _objectSpread2({}, cellStyles, {
        width: "".concat(header.totalWidth, "px")
      })
    };
  });
  getCellProps.push(function (cell) {
    return {
      style: _objectSpread2({}, cellStyles, {
        width: "".concat(cell.column.totalWidth, "px")
      })
    };
  });
  return instance;
};

exports.actions = actions;
exports.applyHooks = applyHooks;
exports.applyPropHooks = applyPropHooks;
exports.defaultColumn = defaultColumn;
exports.defaultGroupByFn = defaultGroupByFn;
exports.defaultOrderByFn = defaultOrderByFn;
exports.ensurePluginOrder = ensurePluginOrder;
exports.functionalUpdate = functionalUpdate;
exports.mergeProps = mergeProps;
exports.safeUseLayoutEffect = safeUseLayoutEffect;
exports.useAbsoluteLayout = useAbsoluteLayout;
exports.useAsyncDebounce = useAsyncDebounce;
exports.useBlockLayout = useBlockLayout;
exports.useColumnOrder = useColumnOrder;
exports.useConsumeHookGetter = useConsumeHookGetter;
exports.useExpanded = useExpanded;
exports.useFilters = useFilters;
exports.useGetLatest = useGetLatest;
exports.useGroupBy = useGroupBy;
exports.useMountedLayoutEffect = useMountedLayoutEffect;
exports.usePagination = usePagination;
exports.useResizeColumns = useResizeColumns;
exports.useRowSelect = useRowSelect;
exports.useRowState = useRowState;
exports.useSortBy = useSortBy;
exports.useTable = useTable;
//# sourceMappingURL=index.js.map
